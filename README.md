LAP - Raytracing Hardware Accelerator for FPGA
==========

__Brief__: Repository for the raytracing hardware accelerator designed for FPGAs in Chisel at the LAP - EPFL.  

Content
--------
This repository contains both the ***Chisel*** code for the Accelerator and the ***C++*** code for the completed version of *[Nori](https://wjakob.github.io/nori/)*.   
Also contains modules generated using Vivado HLS.  

DONE
------
### Finish Chisel book  

### Finish reading through PBRT  

### Finish reading through Nori-fpga  

### Draw architecture for Ray-intersect  

### Finish going through the HLS tutorial
==> The PDF sent by Mikhail.  
The main goal is to find the synthetiser directives so that we can control the generated HW a little more.    

### Finish blackboxing bboxIntersect HLS module
The chisel blackbox module has to be completed to interface the verilog code genrated by Vivado HLS and the Chisel Raytracer.  
> _Note_: The actual blackbox has already been designed, the only problem is that the IOs generated by HLS are quite complex and numerous, thus the idea would be to create a blackbox module to simplify the IOs so that they resemble the ones given to the function in the SoftWare raytracer.  
>> Update: This has been done and we have comprehensible blackboxes for both prim-intersect and bbox-intersect.   

### Adapt and Synthetise primitiveIntersect  
The code from the triangle's RayIntersect method has already been isolated, all that's left to do now is to adapt it so that the following issues can be solved:  
 1. Solve all type depedencies (by redefining them in the containing file)   
 2. Solve all library dependencies (by recoding the functions not handle by the standard library)  
 3. Adapting the top level function so that it works with the newly coded library functions.  

### Blackbox the primitiveIntersect HLS module  
Same idea as with bboxIntersect, so try to blackbox the HLS module so that the IOs are the same as in the SW raytracer.  

### Figure out how to fetch the BVH tree  
This should also take into account handling the ray IDing (so that the fetching can be parallelized).   
> This is where Mikhail's Memory Controller should come into play.  
__IDEA__: Use a simple memory controller using two decoupled IOs (\{address, valid\} && \{data, valid\}) to go and fetch the root of the tree.   
> _Note on the use of decoupled IOs_: Since here we are working with out-of-order requests the decouple IOs will mostly look like \{adress, ID, valid\} && \{data, ID, valid\}; the id here would be used to track fir which ray we are fetching the root.  
__Question__: How to obtain the correct address for the root.  

### Draw a clearer top-level schema of the Architecture 
This also implies updating the IOs and removing the elements that were simplified.  

TODO 
------

### Test the generated HLS modules
This can be done by gathering test samples form the software raytracer (by getting the ray values at different parts in the execution process).  
Once the test samples have been found, write chisel test-benches to test that the blackboxed version of the functions work.  

### Implement the Fetch BVH
This can easily be done using the design from the presentation slides (+ a few details).  

### Write a testBench for Fetch 
This can be done by getting the BVH and rays directly from the original raytracer and then feeding those inputs to the fetching component via the testbench.  

### Finish designing Traversal  
Figure out how to integrate the BBox-RayIntersect into the overall raytracer.   

### Implement the Traversal block  
Using the premade design.  

### Test the Traversal component 


  
  


 
 
